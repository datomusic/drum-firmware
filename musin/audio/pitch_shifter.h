#ifndef PITCH_SHIFTER_H_0GR8ZAHC
#define PITCH_SHIFTER_H_0GR8ZAHC

#include <algorithm>
#include <cmath> // Added for floor()
#include <cstdint>

#include "port/section_macros.h"

// Removed #include "buffered_reader.h"
#include "dspinst.h"
#include "musin/hal/debug_utils.h" // For underrun counter
#include "sample_reader.h"         // Includes block.h for AudioBlock

// Interpolator strategies
struct CubicInterpolator {
  constexpr static int16_t
  __time_critical_func(interpolate)(const int16_t y0, const int16_t y1, const int16_t y2,
                                     const int16_t y3, const float mu) {
    const float mu2 = mu * mu;
    const float mu3 = mu2 * mu;

    // Catmull-Rom cubic interpolation coefficients
    const float a0 = -0.5f * y0 + 1.5f * y1 - 1.5f * y2 + 0.5f * y3;
    const float a1 = y0 - 2.5f * y1 + 2.0f * y2 - 0.5f * y3;
    const float a2 = -0.5f * y0 + 0.5f * y2;
    const float a3 = y1;

    float result = a0 * mu3 + a1 * mu2 + a2 * mu + a3;

    // Clamp to int16_t range
    result = std::clamp(result, -32768.0f, 32767.0f);

    return static_cast<int16_t>(result);
  }
};

struct NearestNeighborInterpolator {
  constexpr static int16_t
  __time_critical_func(interpolate)(const int16_t /*y0*/, const int16_t y1, const int16_t y2,
                                     const int16_t /*y3*/, const float mu) {
    // y0 and y3 are not used for nearest neighbor interpolation focusing on y1 and y2.
    // mu is the fractional position between y1 and y2.
    if (mu < 0.5f) {
      return y1;
    } else {
      return y2;
    }
  }
};

template <typename InterpolatorStrategy> struct PitchShifter : SampleReader {
  constexpr PitchShifter(SampleReader &reader)
      : speed(1.0f), sample_reader(reader), m_internal_buffer_read_idx(0),
        m_internal_buffer_valid_samples(0), has_reached_end(false) {
    // Initialize interpolation buffer to avoid clicks/pops
    reset();
  }

  // Reader interface
  constexpr void reset() override {
    // Pre-fill interpolation buffer with first sample or zeros
    // This helps prevent clicks/pops at the beginning
    int16_t first_sample = 0;
    // Try to get the first sample if available
    sample_reader.reset();
    if (sample_reader.has_data()) {
      sample_reader.read_next(first_sample);
      sample_reader.reset(); // Reset again after reading the first sample
    }

    for (int i = 0; i < 4; i++) {
      interpolation_samples[i] = first_sample;
    }

    position = 0.0f;
    buffer_position = 0;
    source_index = 0;
    has_reached_end = false;

    // Reset internal buffer for read_next when resampling
    m_internal_buffer_read_idx = 0;
    m_internal_buffer_valid_samples = 0;
  }

  // Reader interface
  constexpr bool has_data() override {
    if (this->speed > 0.99f && this->speed < 1.01f) {
      return sample_reader.has_data();
    } else {
      // Either we have buffered samples or the source still has data
      // or we're still processing the last few samples in the interpolation buffer
      return (m_internal_buffer_read_idx < m_internal_buffer_valid_samples) ||
             sample_reader.has_data() || !has_reached_end;
    }
  }

  // Reader interface
  constexpr bool read_next(int16_t &out) override {
    if (this->speed > 0.99f && this->speed < 1.01f) {
      // Passthrough directly from the source reader
      return sample_reader.read_next(out);
    } else {
      // Resampling path: use internal buffer
      if (m_internal_buffer_read_idx >= m_internal_buffer_valid_samples) {
        // Buffer is exhausted, try to refill it by calling read_resampled
        m_internal_buffer_valid_samples = read_resampled(m_internal_buffer);
        m_internal_buffer_read_idx = 0; // Reset read index for the new buffer content

        if (m_internal_buffer_valid_samples == 0) {
          // No more samples could be generated by read_resampled
          out = 0; // Provide a default silence value
          return false;
        }
      }
      // Provide the next sample from the internal buffer
      out = m_internal_buffer[m_internal_buffer_read_idx++];
      return true;
    }
  }

  // Reader interface
  constexpr uint32_t read_samples(AudioBlock &out) override {
    // Fast path for essentially unmodified speed
    if (this->speed > 0.99f && this->speed < 1.01f) {
      return sample_reader.read_samples(out);
    } else {
      return read_resampled(out);
    }
  }

  constexpr void set_speed(const float new_speed) {
    // Clamp speed to valid range
    if (new_speed < 0.2f) {
      this->speed = 0.2f;
    } else if (new_speed > 2.0f) {
      this->speed = 2.0f;
    } else {
      this->speed = new_speed;
    }
  }

private:
  constexpr uint32_t __time_critical_func(read_resampled)(AudioBlock &out) {
    int16_t sample = 0;
    uint32_t samples_generated = 0;
    float current_position = position;

    // Process each output sample
    for (uint32_t out_sample_index = 0; out_sample_index < out.size(); ++out_sample_index) {
      // Get the integer and fractional parts of the current position
      int new_buffer_position = static_cast<int>(std::floor(current_position));
      float mu = current_position - static_cast<float>(new_buffer_position);

      // Ensure we have enough samples in the buffer for interpolation
      bool has_more_data = true;
      while (source_index <= new_buffer_position + 3 && has_more_data) {
        has_more_data = sample_reader.read_next(sample);
        if (!has_more_data) {
          // Reached the end of input data
          has_reached_end = true;
          // Don't immediately exit - we can still use the samples in the buffer
          // Just pad with zeros if needed
          sample = 0;
        }

        shift_interpolation_samples(sample);
        source_index++;
      }

      // Calculate interpolated value even if we've reached the end of the source data
      // This allows us to use the remaining samples in the interpolation buffer

      // Get interpolation buffer indices relative to our current position
      // Ensure we're using the correct indices from our circular buffer
      int idx_offset = new_buffer_position - (source_index - 4);

      // Safely access the circular buffer
      const int16_t y0 = interpolation_samples[(0 + idx_offset) & 3];
      const int16_t y1 = interpolation_samples[(1 + idx_offset) & 3];
      const int16_t y2 = interpolation_samples[(2 + idx_offset) & 3];
      const int16_t y3 = interpolation_samples[(3 + idx_offset) & 3];

      // Calculate interpolated value
      const int16_t interpolated_value = InterpolatorStrategy::interpolate(y0, y1, y2, y3, mu);

      // Write the interpolated sample to output
      out[out_sample_index] = interpolated_value;
      samples_generated++;

      // Advance position based on playback speed
      current_position += this->speed;

      // If we've moved past the available data and we've already reached the end,
      // start fading out the sound to avoid abrupt stopping
      if (has_reached_end && new_buffer_position > source_index) {
        // Only continue for a few more samples to provide a smooth tail-off
        int samples_beyond_end = new_buffer_position - source_index;
        if (samples_beyond_end > 8) { // Arbitrary cutoff for tail fade-out
          // Fill the rest of the output buffer with silence
          for (uint32_t i = out_sample_index + 1; i < out.size(); ++i) {
            out[i] = 0;
          }
          samples_generated = out_sample_index + 1;
          break; // Exit the main sample generation loop
        }
      }
    }

    if (samples_generated < out.size() && sample_reader.has_data()) {
      // If we didn't fill the block but the underlying reader still has data,
      // it's a pitch shifter specific underrun (couldn't process fast enough
      // or logic error in resampling).
      musin::hal::DebugUtils::g_pitch_shifter_underruns++;
    }

    // Save position for next call
    position = current_position;
    buffer_position = static_cast<int>(std::floor(position));

    return samples_generated;
  }

  constexpr void __time_critical_func(shift_interpolation_samples)(const int16_t sample) {
    // Shift samples in the interpolation buffer using a circular buffer approach
    interpolation_samples[0] = interpolation_samples[1];
    interpolation_samples[1] = interpolation_samples[2];
    interpolation_samples[2] = interpolation_samples[3];
    interpolation_samples[3] = sample;
  }

  // Using float instead of double for better performance on Cortex-M33 FPU
  float speed;
  // Align interpolation buffer to word boundary for better memory access
  alignas(4) int16_t interpolation_samples[4];
  uint32_t source_index;
  float position;
  int buffer_position;
  SampleReader &sample_reader;
  // musin::BufferedReader<> buffered_reader; // Removed
  bool has_reached_end; // Tracks if we've reached the end of source data

  // Internal buffer for read_next when resampling
  AudioBlock m_internal_buffer;
  uint32_t m_internal_buffer_read_idx;
  uint32_t m_internal_buffer_valid_samples;
};

#endif /* end of include guard: PITCH_SHIFTER_H_0GR8ZAHC */
