#include "musin/drivers/ws2812.h"
#include <algorithm> // For std::min, std::fill
#include <vector>

// Wrap C SDK headers
extern "C" {
#include <stdio.h> // Optional: For printf debugging if needed
#include "hardware/pio.h"
#include "hardware/clocks.h"
#include "hardware/dma.h"
#include "hardware/irq.h"
#include "pico/assert.h"
}
#include <climits>
// Include the header generated by pioasm from ws2812.pio
// The build system (CMake) must be configured to generate this.
#include "ws2812.pio.h"

namespace Musin::Drivers {

// Static members for manual program loading are removed.

// Helper function load_pio_program_once is removed.

WS2812::WS2812(unsigned int data_pin, unsigned int num_leds,
               RGBOrder order, uint8_t initial_brightness,
               std::optional<uint32_t> color_correction)
    : _pio(nullptr),
      _sm_index(UINT_MAX),
      _data_pin(data_pin),
      _num_leds(num_leds),
      _order(order),
      _brightness(initial_brightness),
      _color_correction(color_correction),
      _pixel_buffer(num_leds, 0)
{
    // Asserts for pio/sm_index removed as they are no longer constructor arguments.
    assert(num_leds > 0);
}

bool WS2812::init() {
    if (_initialized) {
        return true;
    }

    // --- Claim free PIO/SM and Load Program ---
    // Use the SDK helper to find a free PIO/SM, add the ws2812 program,
    // and get the assigned resources.
    // The _for_gpio_range variant ensures compatibility with high GPIOs if needed.
    PIO pio_instance;
    unsigned int sm_idx;
    unsigned int offset;

    // Note: ws2812_program struct is defined in the generated ws2812.pio.h
    bool success = pio_claim_free_sm_and_add_program_for_gpio_range(
        &ws2812_program, &pio_instance, &sm_idx, &offset, _data_pin, 1, true);

    if (!success) {
        return false; // Failed to claim PIO/SM or load program
    }

    _pio = pio_instance;
    _sm_index = sm_idx;
    _pio_program_offset = offset;

    // --- Initialize State Machine using C-SDK Helper ---
    // The ws2812_program_init function is defined in the ws2812.pio.h file (via the % c-sdk block)
    // It handles GPIO init, SM config (sideset, clkdiv, shift), SM init, and enabling.
    // We need to pass the claimed resources and configuration parameters.
    // Assuming 800kHz frequency and not RGBW (standard WS2812 is 24-bit color).
    ws2812_program_init(_pio, _sm_index, _pio_program_offset, _data_pin, 800000, false /* IS_RGBW */);

    _initialized = true;
    return true;
}


void WS2812::set_pixel(unsigned int index, uint8_t r, uint8_t g, uint8_t b) {
    if (!_initialized || index >= _num_leds) {
        // assert(index < _num_leds && _initialized); // Optional: Assert in debug builds
        return;
    }

    uint8_t final_r, final_g, final_b;
    apply_brightness_and_correction(r, g, b, final_r, final_g, final_b);
    _pixel_buffer[index] = pack_color(final_r, final_g, final_b);
}

void WS2812::set_pixel(unsigned int index, uint32_t color) {
     if (!_initialized || index >= _num_leds) {
        // assert(index < _num_leds && _initialized); // Optional: Assert in debug builds
        return;
    }
    // Extract components assuming standard 0xRRGGBB format input
    uint8_t r = (color >> 16) & 0xFF;
    uint8_t g = (color >> 8) & 0xFF;
    uint8_t b = color & 0xFF;
    set_pixel(index, r, g, b); // Reuse RGB version for brightness/correction
}

void WS2812::show() {
    if (!_initialized) {
        // assert(_initialized); // Optional: Assert in debug builds
        return;
    }
    for (uint32_t packed_color : _pixel_buffer) {
        // PIO expects 24 bits, left-aligned in the 32-bit FIFO word (GRB format)
        assert(_pio != nullptr && _sm_index != UINT_MAX);
        pio_sm_put_blocking(_pio, _sm_index, packed_color << 8);
    }
    // Note: A delay after the last bit might be needed for some WS2812 variants
    // to latch the data (typically >50us). The PIO program itself doesn't
    // include this reset time. Add `busy_wait_us(100);` here if needed.
}

void WS2812::clear() {
     if (!_initialized) {
        // assert(_initialized); // Optional: Assert in debug builds
        return;
    }
    std::fill(_pixel_buffer.begin(), _pixel_buffer.end(), 0);
    // Note: Does not call show(). User must call show() to update LEDs.
}

void WS2812::fade_by(uint8_t fade_amount) {
    if (!_initialized) {
        // assert(_initialized); // Optional: Assert in debug builds
        return;
    }
    if (fade_amount == 0) {
        return; // Nothing to do
    }

    for (uint32_t& packed_color : _pixel_buffer) {
        if (packed_color == 0) continue; // Skip black pixels

        uint8_t r, g, b;
        unpack_color(packed_color, r, g, b);

        // Subtract fade_amount, clamping at 0
        r = (r > fade_amount) ? (r - fade_amount) : 0;
        g = (g > fade_amount) ? (g - fade_amount) : 0;
        b = (b > fade_amount) ? (b - fade_amount) : 0;

        packed_color = pack_color(r, g, b);
    }
    // Note: Does not call show(). User must call show() to update LEDs.
}


void WS2812::set_brightness(uint8_t brightness) {
    // Store brightness; applied during the next set_pixel call.
    _brightness = brightness;
}

uint8_t WS2812::get_brightness() const {
    return _brightness;
}

unsigned int WS2812::get_num_leds() const {
    return _num_leds;
}

// --- Private Helper Methods ---

void WS2812::apply_brightness_and_correction(uint8_t r, uint8_t g, uint8_t b,
                                             uint8_t& out_r, uint8_t& out_g, uint8_t& out_b) const {
    // 1. Apply Brightness (using integer math)
    // Scale brightness from 0-255 to 0-256 range for division by 256 (>> 8)
    uint16_t brightness_scale = _brightness + (_brightness == 255 ? 0 : 1); // Map 255->255, others -> val+1
    r = (uint8_t)(( (uint16_t)r * brightness_scale ) >> 8);
    g = (uint8_t)(( (uint16_t)g * brightness_scale ) >> 8);
    b = (uint8_t)(( (uint16_t)b * brightness_scale ) >> 8);

    // 2. Apply Color Correction (if enabled)
    if (_color_correction.has_value()) {
        uint32_t correction = _color_correction.value();
        uint8_t correct_r = (correction >> 16) & 0xFF;
        uint8_t correct_g = (correction >> 8) & 0xFF;
        uint8_t correct_b = correction & 0xFF;

        // Scale components by correction factors (using integer math, scale 0-255 to 0-256 range)
        r = (uint8_t)(( (uint16_t)r * (correct_r + (correct_r == 255 ? 0 : 1)) ) >> 8);
        g = (uint8_t)(( (uint16_t)g * (correct_g + (correct_g == 255 ? 0 : 1)) ) >> 8);
        b = (uint8_t)(( (uint16_t)b * (correct_b + (correct_b == 255 ? 0 : 1)) ) >> 8);
    }

    out_r = r;
    out_g = g;
    out_b = b;
}

uint32_t WS2812::pack_color(uint8_t r, uint8_t g, uint8_t b) const {
    // The PIO program (ws2812.pio) expects GRB data shifted out MSB first.
    // This function packs the R, G, B components into a 24-bit integer
    // according to the specified RGBOrder.
    uint32_t packed = 0;
    switch (_order) {
        case RGBOrder::RGB: packed = ((uint32_t)r << 16) | ((uint32_t)g << 8) | b; break;
        case RGBOrder::RBG: packed = ((uint32_t)r << 16) | ((uint32_t)b << 8) | g; break;
        case RGBOrder::GRB: packed = ((uint32_t)g << 16) | ((uint32_t)r << 8) | b; break;
        case RGBOrder::GBR: packed = ((uint32_t)g << 16) | ((uint32_t)b << 8) | r; break;
        case RGBOrder::BRG: packed = ((uint32_t)b << 16) | ((uint32_t)r << 8) | g; break;
        case RGBOrder::BGR: packed = ((uint32_t)b << 16) | ((uint32_t)g << 8) | r; break;
    }
    return packed;
}

void WS2812::unpack_color(uint32_t packed_color, uint8_t& r, uint8_t& g, uint8_t& b) const {
    // Reverse the packing logic based on the configured order
    switch (_order) {
        case RGBOrder::RGB:
            r = (packed_color >> 16) & 0xFF;
            g = (packed_color >> 8) & 0xFF;
            b = packed_color & 0xFF;
            break;
        case RGBOrder::RBG:
            r = (packed_color >> 16) & 0xFF;
            b = (packed_color >> 8) & 0xFF;
            g = packed_color & 0xFF;
            break;
        case RGBOrder::GRB: // Common
            g = (packed_color >> 16) & 0xFF;
            r = (packed_color >> 8) & 0xFF;
            b = packed_color & 0xFF;
            break;
        case RGBOrder::GBR:
            g = (packed_color >> 16) & 0xFF;
            b = (packed_color >> 8) & 0xFF;
            r = packed_color & 0xFF;
            break;
        case RGBOrder::BRG:
            b = (packed_color >> 16) & 0xFF;
            r = (packed_color >> 8) & 0xFF;
            g = packed_color & 0xFF;
            break;
        case RGBOrder::BGR:
            b = (packed_color >> 16) & 0xFF;
            g = (packed_color >> 8) & 0xFF;
            r = packed_color & 0xFF;
            break;
        default: // Should not happen with enum class, but handle defensively
            r = g = b = 0;
            break;
    }
}


} // namespace Musin::Drivers
