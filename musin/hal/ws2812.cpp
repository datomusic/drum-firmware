#include "musin/hal/ws2812.h"
#include <algorithm> // For std::min, std::fill
#include <vector>

// Wrap C SDK headers
extern "C" {
#include <stdio.h> // For printf debugging (optional)
#include "hardware/pio.h"
#include "hardware/clocks.h"
#include "hardware/dma.h" // Consider for future optimization
#include "hardware/irq.h" // Consider for future optimization
#include "pico/assert.h" // For assertions
}
#include <climits>
// Include the header generated by pioasm from ws2812.pio
// The build system (CMake) must be configured to generate this.
#include "ws2812.pio.h"

namespace Musin::HAL { // Correct namespace

// Static members for manual program loading are removed.

// Helper function load_pio_program_once is removed.


WS2812::WS2812(unsigned int data_pin, unsigned int num_leds, // Use unsigned int
               RGBOrder order, uint8_t initial_brightness,
               std::optional<uint32_t> color_correction)
    : _pio(nullptr), // Initialize PIO to null, will be set in init()
      _sm_index(UINT_MAX), // Initialize SM index to invalid, will be set in init()
      _data_pin(data_pin),
      _num_leds(num_leds),
      _order(order),
      _brightness(initial_brightness),
      _color_correction(color_correction),
      _pixel_buffer(num_leds, 0) // Allocate buffer and initialize to black
{
    // Asserts for pio/sm_index removed as they are no longer constructor arguments.
    // Assert for num_leds is reasonable.
    assert(num_leds > 0);
}

bool WS2812::init() {
    if (_initialized) {
        return true; // Already initialized
    }

    // --- Claim free PIO/SM and Load Program ---
    // Use the SDK helper to find a free PIO instance and state machine,
    // add the ws2812 program, and get the assigned resources.
    // We use the _for_gpio_range variant to ensure compatibility with high GPIOs if needed.
    PIO pio_instance;          // Local variable to receive the chosen PIO
    unsigned int sm_idx;       // Local variable to receive the chosen SM index (Use unsigned int)
    unsigned int offset;       // Local variable to receive the program offset

    // Note: The ws2812_program struct is defined in the generated ws2812.pio.h
    bool success = pio_claim_free_sm_and_add_program_for_gpio_range(
        &ws2812_program, &pio_instance, &sm_idx, &offset, _data_pin, 1, true);

    if (!success) {
        // printf("Error: Failed to claim free PIO state machine or add WS2812 program.\n");
        return false;
    }

    // Store the claimed resources
    _pio = pio_instance;
    _sm_index = sm_idx; // No cast needed if local is unsigned int
    _pio_program_offset = offset;

    // --- Initialize State Machine using C-SDK Helper ---
    // The ws2812_program_init function is defined in the ws2812.pio.h file (via the % c-sdk block)
    // It handles GPIO init, SM config (sideset, clkdiv, shift), SM init, and enabling.
    // We need to pass the claimed resources and configuration parameters.
    // Assuming 800kHz frequency and not RGBW (standard WS2812 is 24-bit color).
    ws2812_program_init(_pio, _sm_index, _pio_program_offset, _data_pin, 800000, false); // false for IS_RGBW

    _initialized = true;
    // printf("Info: WS2812 driver initialized on PIO%u SM%u Pin%u (Offset %u)\n", pio_get_index(_pio), _sm_index, _data_pin, _pio_program_offset);
    return true; // Indicate success
}


void WS2812::set_pixel(unsigned int index, uint8_t r, uint8_t g, uint8_t b) { // Use unsigned int
    if (!_initialized || index >= _num_leds) {
        // Consider assertion failure in debug builds: assert(index < _num_leds && _initialized);
        return; // Ignore if not initialized or index out of bounds
    }

    uint8_t final_r, final_g, final_b;
    apply_brightness_and_correction(r, g, b, final_r, final_g, final_b);
    _pixel_buffer[index] = pack_color(final_r, final_g, final_b);
}

void WS2812::set_pixel(unsigned int index, uint32_t color) { // Use unsigned int
     if (!_initialized || index >= _num_leds) {
        // assert(index < _num_leds && _initialized);
        return;
    }
    // Extract components assuming standard 0xRRGGBB format input
    uint8_t r = (color >> 16) & 0xFF;
    uint8_t g = (color >> 8) & 0xFF;
    uint8_t b = color & 0xFF;
    set_pixel(index, r, g, b); // Reuse the other set_pixel implementation for brightness/correction
}

void WS2812::show() {
    if (!_initialized) {
        // assert(_initialized);
        return;
    }
    for (uint32_t packed_color : _pixel_buffer) {
        // PIO expects 24 bits, left-aligned in the 32-bit FIFO word (<< 8)
        // Ensure _pio and _sm_index are valid before calling this
        assert(_pio != nullptr && _sm_index != UINT_MAX);
        pio_sm_put_blocking(_pio, _sm_index, packed_color << 8);
    }
    // Note: A delay after the last bit might be needed for some WS2812 variants
    // to latch the data. The PIO program itself doesn't include this reset time.
    // A common value is >50us, but often things work without an explicit delay here
    // if there's other processing happening soon after. Add if needed.
    // busy_wait_us(100);
}

void WS2812::clear() {
     if (!_initialized) {
        // assert(_initialized);
        return;
    }
    // Set all pixels in the buffer to 0 (black)
    std::fill(_pixel_buffer.begin(), _pixel_buffer.end(), 0);
    // Note: Does not call show(). User must call show() to update LEDs.
}

void WS2812::set_brightness(uint8_t brightness) {
    // Just store the brightness. It will be applied during the next set_pixel call.
    _brightness = brightness;
}

uint8_t WS2812::get_brightness() const {
    return _brightness;
}

unsigned int WS2812::get_num_leds() const { // Already unsigned int, good.
    return _num_leds;
}

// --- Private Helper Methods ---

void WS2812::apply_brightness_and_correction(uint8_t r, uint8_t g, uint8_t b,
                                             uint8_t& out_r, uint8_t& out_g, uint8_t& out_b) const {
    // 1. Apply Brightness (using integer math for embedded)
    // Scale brightness from 0-255 to 0-256 for easier division
    uint16_t brightness_scale = _brightness + (_brightness == 255 ? 0 : 1); // Map 255->255, others -> +1
    r = (uint8_t)(( (uint16_t)r * brightness_scale ) >> 8);
    g = (uint8_t)(( (uint16_t)g * brightness_scale ) >> 8);
    b = (uint8_t)(( (uint16_t)b * brightness_scale ) >> 8);

    // 2. Apply Color Correction (if enabled)
    if (_color_correction.has_value()) {
        uint32_t correction = _color_correction.value();
        uint8_t correct_r = (correction >> 16) & 0xFF;
        uint8_t correct_g = (correction >> 8) & 0xFF;
        uint8_t correct_b = correction & 0xFF;

        // Scale components by correction factors (again, using integer math)
        r = (uint8_t)(( (uint16_t)r * (correct_r + (correct_r == 255 ? 0 : 1)) ) >> 8);
        g = (uint8_t)(( (uint16_t)g * (correct_g + (correct_g == 255 ? 0 : 1)) ) >> 8);
        b = (uint8_t)(( (uint16_t)b * (correct_b + (correct_b == 255 ? 0 : 1)) ) >> 8);
    }

    out_r = r;
    out_g = g;
    out_b = b;
}

uint32_t WS2812::pack_color(uint8_t r, uint8_t g, uint8_t b) const {
    // Pack into GRB format for the PIO program which expects GRB data shifted out MSB first.
    // The PIO program itself handles the bit timings.
    uint32_t packed = 0;
    switch (_order) {
        // Shift components into a 24-bit value based on the specified order
        case RGBOrder::RGB: packed = ((uint32_t)r << 16) | ((uint32_t)g << 8) | b; break;
        case RGBOrder::RBG: packed = ((uint32_t)r << 16) | ((uint32_t)b << 8) | g; break;
        case RGBOrder::GRB: packed = ((uint32_t)g << 16) | ((uint32_t)r << 8) | b; break; // Common
        case RGBOrder::GBR: packed = ((uint32_t)g << 16) | ((uint32_t)b << 8) | r; break;
        case RGBOrder::BRG: packed = ((uint32_t)b << 16) | ((uint32_t)r << 8) | g; break;
        case RGBOrder::BGR: packed = ((uint32_t)b << 16) | ((uint32_t)g << 8) | r; break;
    }
    return packed;
}


} // namespace Musin::HAL
