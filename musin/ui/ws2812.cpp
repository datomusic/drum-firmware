#include "musin/ui/ws2812.h"
#include <algorithm> // For std::min, std::fill
#include <vector>

// Wrap C SDK headers
extern "C" {
#include <stdio.h> // For printf debugging (optional)
#include "hardware/pio.h"
#include "hardware/clocks.h"
#include "hardware/dma.h" // Consider for future optimization
#include "hardware/irq.h" // Consider for future optimization
#include "pico/assert.h" // For assertions
}

// Include the header generated by pioasm from ws2812.pio
// The build system (CMake) must be configured to generate this.
#include "ws2812.pio.h"

namespace Musin::UI {

// Define static members
bool WS2812::_pio_program_loaded[NUM_PIOS] = {false}; // Initialize all to false
uint WS2812::_loaded_pio_program_offset[NUM_PIOS] = {0};
const struct pio_program* WS2812::_pio_program_ptr = &ws2812_program; // From ws2812.pio.h

// Helper to load the PIO program only once per PIO instance
bool WS2812::load_pio_program_once(PIO pio, uint& offset_out) {
    uint pio_index = pio_get_index(pio);
    assert(pio_index < NUM_PIOS);

    if (!_pio_program_loaded[pio_index]) {
        if (!pio_can_add_program(pio, _pio_program_ptr)) {
            // printf("Error: Cannot add WS2812 PIO program to PIO%u - not enough space.\n", pio_index);
            return false; // Not enough space
        }
        _loaded_pio_program_offset[pio_index] = pio_add_program(pio, _pio_program_ptr);
        _pio_program_loaded[pio_index] = true;
        // printf("Info: WS2812 PIO program loaded to PIO%u at offset %u.\n", pio_index, _loaded_pio_program_offset[pio_index]);
    }
    offset_out = _loaded_pio_program_offset[pio_index];
    return true;
}


WS2812::WS2812(PIO pio, uint sm_index, uint data_pin, uint num_leds,
               RGBOrder order, uint8_t initial_brightness,
               std::optional<uint32_t> color_correction)
    : _pio(pio),
      _sm_index(sm_index),
      _data_pin(data_pin),
      _num_leds(num_leds),
      _order(order),
      _brightness(initial_brightness),
      _color_correction(color_correction),
      _pixel_buffer(num_leds, 0) // Allocate buffer and initialize to black
{
    assert(pio == pio0 || pio == pio1);
    assert(sm_index < NUM_PIO_STATE_MACHINES);
    assert(num_leds > 0);
}

bool WS2812::init() {
    if (_initialized) {
        return true; // Already initialized
    }

    // --- Load PIO Program (if needed for this PIO instance) ---
    if (!load_pio_program_once(_pio, _pio_program_offset)) {
        return false; // Failed to load program (e.g., PIO full)
    }

    // --- Claim State Machine ---
    // Use pio_claim_sm instead of checking sm_is_claimed for atomicity,
    // although in typical single-threaded init it doesn't matter much.
    // pio_claim_sm is deprecated, use sm_claim
    // int claim_result = pio_claim_sm(_pio, _sm_index); // Deprecated
    // A simple check is often sufficient if init is controlled:
    if (pio_sm_is_claimed(_pio, _sm_index)) {
         // printf("Error: Cannot claim PIO%u state machine %u - already claimed.\n", pio_get_index(_pio), _sm_index);
         // Optionally, treat as success if already initialized by another instance? No, let's be strict.
         return false;
    }
    pio_sm_claim(_pio, _sm_index); // Claim it now


    // --- Configure State Machine ---
    pio_sm_config sm_config = ws2812_program_get_default_config(_pio_program_offset);

    // Map the state machine's side-set pin group to the data pin
    sm_config_set_sideset_pins(&sm_config, _data_pin);

    // Configure FIFO joining: TX FIFO only needed, join them for max depth
    sm_config_set_fifo_join(&sm_config, PIO_FIFO_JOIN_TX);

    // Configure clock divider based on system clock
    // WS2812 requires 800kHz signal.
    // The PIO program from ws2812.pio takes 2 cycles per bit.
    // Required PIO freq = 800,000 bits/sec * 2 cycles/bit = 1,600,000 Hz = 1.6 MHz
    float freq = 1.6f * 1000 * 1000;
    float div = (float)clock_get_hz(clk_sys) / freq;
    sm_config_set_clkdiv(&sm_config, div);

    // Configure shift direction: MSB first, autopull enabled
    sm_config_set_out_shift(&sm_config, false, true, 24); // Shift right (MSB first), autopull every 24 bits

    // --- Initialize GPIO ---
    pio_gpio_init(_pio, _data_pin);
    pio_sm_set_consecutive_pindirs(_pio, _sm_index, _data_pin, 1, true); // Set pin to output

    // --- Load Config and Enable SM ---
    pio_sm_init(_pio, _sm_index, _pio_program_offset, &sm_config);
    pio_sm_set_enabled(_pio, _sm_index, true);

    _initialized = true;
    // printf("Info: WS2812 driver initialized on PIO%u SM%u Pin%u\n", pio_get_index(_pio), _sm_index, _data_pin);
    return true;
}


void WS2812::set_pixel(uint index, uint8_t r, uint8_t g, uint8_t b) {
    if (!_initialized || index >= _num_leds) {
        // Consider assertion failure in debug builds: assert(index < _num_leds && _initialized);
        return; // Ignore if not initialized or index out of bounds
    }

    uint8_t final_r, final_g, final_b;
    apply_brightness_and_correction(r, g, b, final_r, final_g, final_b);
    _pixel_buffer[index] = pack_color(final_r, final_g, final_b);
}

void WS2812::set_pixel(uint index, uint32_t color) {
     if (!_initialized || index >= _num_leds) {
        // assert(index < _num_leds && _initialized);
        return;
    }
    // Extract components assuming standard 0xRRGGBB format input
    uint8_t r = (color >> 16) & 0xFF;
    uint8_t g = (color >> 8) & 0xFF;
    uint8_t b = color & 0xFF;
    set_pixel(index, r, g, b); // Reuse the other set_pixel implementation for brightness/correction
}

void WS2812::show() {
    if (!_initialized) {
        // assert(_initialized);
        return;
    }
    for (uint32_t packed_color : _pixel_buffer) {
        // PIO expects 24 bits, left-aligned in the 32-bit FIFO word (<< 8)
        pio_sm_put_blocking(_pio, _sm_index, packed_color << 8);
    }
    // Note: A delay after the last bit might be needed for some WS2812 variants
    // to latch the data. The PIO program itself doesn't include this reset time.
    // A common value is >50us, but often things work without an explicit delay here
    // if there's other processing happening soon after. Add if needed.
    // busy_wait_us(100);
}

void WS2812::clear() {
     if (!_initialized) {
        // assert(_initialized);
        return;
    }
    // Set all pixels in the buffer to 0 (black)
    std::fill(_pixel_buffer.begin(), _pixel_buffer.end(), 0);
    // Note: Does not call show(). User must call show() to update LEDs.
}

void WS2812::set_brightness(uint8_t brightness) {
    // Just store the brightness. It will be applied during the next set_pixel call.
    _brightness = brightness;
}

uint8_t WS2812::get_brightness() const {
    return _brightness;
}

uint WS2812::get_num_leds() const {
    return _num_leds;
}

// --- Private Helper Methods ---

void WS2812::apply_brightness_and_correction(uint8_t r, uint8_t g, uint8_t b,
                                             uint8_t& out_r, uint8_t& out_g, uint8_t& out_b) const {
    // 1. Apply Brightness (using integer math for embedded)
    // Scale brightness from 0-255 to 0-256 for easier division
    uint16_t brightness_scale = _brightness + (_brightness == 255 ? 0 : 1); // Map 255->255, others -> +1
    r = (uint8_t)(( (uint16_t)r * brightness_scale ) >> 8);
    g = (uint8_t)(( (uint16_t)g * brightness_scale ) >> 8);
    b = (uint8_t)(( (uint16_t)b * brightness_scale ) >> 8);

    // 2. Apply Color Correction (if enabled)
    if (_color_correction.has_value()) {
        uint32_t correction = _color_correction.value();
        uint8_t correct_r = (correction >> 16) & 0xFF;
        uint8_t correct_g = (correction >> 8) & 0xFF;
        uint8_t correct_b = correction & 0xFF;

        // Scale components by correction factors (again, using integer math)
        r = (uint8_t)(( (uint16_t)r * (correct_r + (correct_r == 255 ? 0 : 1)) ) >> 8);
        g = (uint8_t)(( (uint16_t)g * (correct_g + (correct_g == 255 ? 0 : 1)) ) >> 8);
        b = (uint8_t)(( (uint16_t)b * (correct_b + (correct_b == 255 ? 0 : 1)) ) >> 8);
    }

    out_r = r;
    out_g = g;
    out_b = b;
}

uint32_t WS2812::pack_color(uint8_t r, uint8_t g, uint8_t b) const {
    // Pack into GRB format for the PIO program which expects GRB data shifted out MSB first.
    // The PIO program itself handles the bit timings.
    uint32_t packed = 0;
    switch (_order) {
        // Shift components into a 24-bit value based on the specified order
        case RGBOrder::RGB: packed = ((uint32_t)r << 16) | ((uint32_t)g << 8) | b; break;
        case RGBOrder::RBG: packed = ((uint32_t)r << 16) | ((uint32_t)b << 8) | g; break;
        case RGBOrder::GRB: packed = ((uint32_t)g << 16) | ((uint32_t)r << 8) | b; break; // Common
        case RGBOrder::GBR: packed = ((uint32_t)g << 16) | ((uint32_t)b << 8) | r; break;
        case RGBOrder::BRG: packed = ((uint32_t)b << 16) | ((uint32_t)r << 8) | g; break;
        case RGBOrder::BGR: packed = ((uint32_t)b << 16) | ((uint32_t)g << 8) | r; break;
    }
    return packed;
}


} // namespace Musin::UI
